{"version":3,"file":"badger-accordion.min.js","sources":["../src/js/array-from-polyfill.js","../src/js/transition-end.js","../src/js/badger-accordion.js"],"sourcesContent":["if (!Array.from) {\n    Array.from = (function() {\n        var toStr = Object.prototype.toString;\n        var isCallable = function(fn) {\n            return typeof fn === 'function' || toStr.call(fn) === '[object Function]';\n        };\n        var toInteger = function(value) {\n            var number = Number(value);\n            if (isNaN(number)) {\n                return 0;\n            }\n            if (number === 0 || !isFinite(number)) {\n                return number;\n            }\n            return (\n                number > 0\n                    ? 1\n                    : -1) * Math.floor(Math.abs(number));\n        };\n        var maxSafeInteger = Math.pow(2, 53) - 1;\n        var toLength = function(value) {\n            var len = toInteger(value);\n            return Math.min(Math.max(len, 0), maxSafeInteger);\n        };\n\n        // The length property of the from method is 1.\n        return function from(arrayLike/* , mapFn, thisArg */) {\n            // 1. Let C be the this value.\n            var C = this;\n\n            // 2. Let items be ToObject(arrayLike).\n            var items = Object(arrayLike);\n\n            // 3. ReturnIfAbrupt(items).\n            if (arrayLike == null) {\n                throw new TypeError('Array.from requires an array-like object - not null or undefined');\n            }\n\n            // 4. If mapfn is undefined, then let mapping be false.\n            var mapFn = arguments.length > 1\n                ? arguments[1]\n                : void undefined;\n            var T;\n            if (typeof mapFn !== 'undefined') {\n                // 5. else\n                // 5. a If IsCallable(mapfn) is false, throw a TypeError exception.\n                if (!isCallable(mapFn)) {\n                    throw new TypeError('Array.from: when provided, the second argument must be a function');\n                }\n\n                // 5. b. If thisArg was supplied, let T be thisArg; else let T be undefined.\n                if (arguments.length > 2) {\n                    T = arguments[2];\n                }\n            }\n\n            // 10. Let lenValue be Get(items, \"length\").\n            // 11. Let len be ToLength(lenValue).\n            var len = toLength(items.length);\n\n            // 13. If IsConstructor(C) is true, then\n            // 13. a. Let A be the result of calling the [[Construct]] internal method\n            // of C with an argument list containing the single item len.\n            // 14. a. Else, Let A be ArrayCreate(len).\n            var A = isCallable(C)\n                ? Object(new C(len))\n                : new Array(len);\n\n            // 16. Let k be 0.\n            var k = 0;\n            // 17. Repeat, while k < lenâ€¦ (also steps a - h)\n            var kValue;\n            while (k < len) {\n                kValue = items[k];\n                if (mapFn) {\n                    A[k] = typeof T === 'undefined'\n                        ? mapFn(kValue, k)\n                        : mapFn.call(T, kValue, k);\n                } else {\n                    A[k] = kValue;\n                }\n                k += 1;\n            }\n            // 18. Let putStatus be Put(A, \"length\", len, true).\n            A.length = len;\n            // 20. Return A.\n            return A;\n        };\n    }());\n}\n\n/* eslint-disable no-undef */\nexport default module;\n","/*\n\tBy Osvaldas Valutis, www.osvaldas.info\n\tAvailable for use under the MIT License\n*/\n/* eslint-disable no-unused-vars */\n(function(document, window) {\n    let el = document.body || document.documentElement,\n        s = el.style,\n        prefixAnimation = '',\n        prefixTransition = '';\n\n    if (s.WebkitAnimation == '')\n        prefixAnimation = '-webkit-';\n    if (s.MozAnimation == '')\n        prefixAnimation = '-moz-';\n    if (s.OAnimation == '')\n        prefixAnimation = '-o-';\n\n    if (s.WebkitTransition == '')\n        prefixTransition = '-webkit-';\n    if (s.MozTransition == '')\n        prefixTransition = '-moz-';\n    if (s.OTransition == '')\n        prefixTransition = '-o-';\n\n    Object.defineProperty(Object.prototype, 'onCSSAnimationEnd', {\n        value: function(callback) {\n            var runOnce = function(e) {\n                callback();\n                e.target.removeEventListener(e.type, runOnce);\n            };\n            this.addEventListener('webkitAnimationEnd', runOnce);\n            this.addEventListener('mozAnimationEnd', runOnce);\n            this.addEventListener('oAnimationEnd', runOnce);\n            this.addEventListener('oanimationend', runOnce);\n            this.addEventListener('animationend', runOnce);\n            if ((prefixAnimation == '' && !('animation' in s)) || getComputedStyle(this)[prefixAnimation + 'animation-duration'] == '0s')\n                callback();\n            return this;\n        },\n        enumerable: false,\n        writable: true\n    });\n\n    Object.defineProperty(Object.prototype, 'onCSSTransitionEnd', {\n        value: function(callback) {\n            var runOnce = function runOnce(e) {\n                callback();\n                e.target.removeEventListener(e.type, runOnce);\n            };\n            this.addEventListener('webkitTransitionEnd', runOnce);\n            this.addEventListener('mozTransitionEnd', runOnce);\n            this.addEventListener('oTransitionEnd', runOnce);\n            this.addEventListener('transitionend', runOnce);\n            this.addEventListener('transitionend', runOnce);\n            if (prefixTransition == '' && !('transition' in s) || getComputedStyle(this)[prefixTransition + 'transition-duration'] == '0s')\n                callback();\n            return this;\n        },\n        enumerable: false,\n        writable: true\n    });\n}(document, window, 0));\n\n/* eslint-disable no-undef */\nexport default module;\n","/**\n *  ACCORDION\n *\n * A lightwight vanilla JS accordion with an exstensible API\n */\n\n// import uuid from 'uuid/v4';\n// const uuidV4 = uuid;\n/* eslint-disable no-unused-vars */\nimport arrayFromPolyfill from 'array-from-polyfill';\nimport onCSSTransitionEnd from 'transition-end';\n\n/**\n * CONSTRUCTOR\n * Initializes the object\n */\nclass BadgerAccordion {\n    constructor(el, options) {\n        const container = typeof el === 'string' ? document.querySelector(el) : el;\n\n        // If el is not defined\n        if (container == null) {\n            return;\n        }\n\n\n        const defaults = {\n            headerClass:        '.js-badger-accordion-header',\n            panelClass:         '.js-badger-accordion-panel',\n            panelInnerClass:    '.js-badger-accordion-panel-inner',\n            hiddenClass:        '-ba-is-hidden',\n            activeClass:        '-ba-is-active',\n            get hidenClass() { return this.hiddenClass; },\n            initializedClass:    'badger-accordion--initialized',\n            get initalisedClass() { return this.initializedClass; },\n            headerDataAttr:     'data-badger-accordion-header-id',\n            openMultiplePanels: false,\n            openHeadersOnLoad:  [],\n            addListenersOnInit: true,\n            headerOpenLabel:    '',\n            headerCloseLabel:   '',\n            roles:              true\n            // toggleEl:            // If you want to use a different element to trigger the accordion\n        };\n\n        // Options\n        this.settings = Object.assign({}, defaults, options);\n\n        // Setting getting elements\n        this.container = container;\n\n        // Selecting children of the current accordion instance\n        const children = Array.from(this.container.children);\n\n        // Since the Accordions header button is nested inside an element with class\n        // of `badger-accordion__header` it is a grandchild of the accordion instance.\n        // In order to have nested accordions we need each to only get all the button\n        // elements for this instance. Here an array is created to show all the children\n        // of the element `badger-accordion__header`.\n        const headerParent = children.filter(header => !header.classList.contains(this.settings.panelClass.substr(1)));\n\n        // Creating an array of all DOM nodes that are Accordion headers\n        this.headers = headerParent.reduce((acc, header) => {\n            // Gets all the elements that have the headerClass\n            const a = Array.from(header.children).filter( child => child.classList.contains( this.settings.headerClass.substr(1) ));\n\n            // Merges the current `badger-accordion__header` accordion triggers\n            // with all the others.\n            acc = [].concat(...acc, a);\n\n            return acc;\n        }, []);\n\n        // Creates an array of all panel elements for this instance of the accordion\n        this.panels = children.filter(panel => panel.classList.contains( this.settings.panelClass.substr(1) ));\n\n        this.toggleEl = this.settings.toggleEl !== undefined ? Array.from(this.container.querySelectorAll(this.settings.toggleEl)) : this.headers;\n\n\n        // This is for managing state of the accordion. It by default sets\n        // all accordion panels to be closed\n        this.states = [].map.call(this.headers, () => {\n            return { state: 'closed' };\n        });\n\n        this.ids = [].map.call(this.headers, () => {\n            return { id: Math.floor((Math.random() * 1000000) + 1) };\n        });\n\n        // This is to ensure that once an open/close event has been fired\n        // another cannot start until the first event has finished.\n        // @TODO - get this working...\n        this.toggling = false;\n\n        // Initiating the accordion\n        if( this.container ) {\n            this.init();\n        } else {\n            /* eslint-disable no-console */\n            console.log('Something is wrong with you markup...');\n        }\n    }\n\n\n    /**\n     *  INIT\n     *\n     *  Initalises the accordion\n     */\n    init() {\n        // Sets up ID, aria attrs & data-attrs\n        this._setupAttributes();\n\n        // Setting up the inital view of the accordion\n        this._initalState();\n\n        // Setting the height of each panel\n        this.calculateAllPanelsHeight();\n\n        // Inserting data-attribute onto each `header`\n        this._insertDataAttrs();\n\n        // Adding listeners to headers\n        this._addListeners();\n\n        // Adds class to accordion for initalisation\n        this._finishInitialization();\n    }\n\n    /**\n     * CHECK ROLES ETTING\n     * @return {[boolean]}\n     * Checks roles setting for all roles or a single role.\n     * First checks if a `boolean` has been used to set all\n     * roles to either true or false. If the setting is an\n     * object it will only set the attribute where each\n     * attribute has explicitly been set as true, eg;\n     * ```\n     * roles: {\n     *     region: true\n     * }\n     * ```\n     */\n    _setRole(role, el) {\n        if(typeof this.settings.roles === 'boolean' && this.settings.roles || this.settings.roles[role] !== undefined && this.settings.roles[role] !== false) {\n            el.setAttribute('role', role);\n        }\n    }\n\n\n    /**\n     *  INSERT DATA ATTRS\n     *\n     *  Updates state object for inital loading of the accordion\n     */\n    _initalState() {\n        // Sets state object as per `this.settings.openHeadersOnLoad`\n        const headersToOpen = this.settings.openHeadersOnLoad;\n\n        if (headersToOpen.length) {\n            this._openHeadersOnLoad(headersToOpen);\n        }\n\n        // Render DOM as per the updates `this.states` object\n        this._renderDom();\n    }\n\n\n    /**\n     *  INSERT DATA ATTRS\n     *\n     *  Adds `headerDataAttr` to all headers\n     */\n    _insertDataAttrs() {\n        this.headers.forEach( (header, index) => {\n            header.setAttribute(this.settings.headerDataAttr, index);\n        });\n    }\n\n\n    /**\n     *  FINISH INITALISATION\n     *\n     *  Adds in `initializedClass` to accordion\n     */\n    _finishInitialization() {\n        this.container.classList.add(this.settings.initializedClass);\n        this._setRole('presentation', this.container);\n    }\n\n\n    /**\n     *  ADD LISTENERS\n     *\n     *  Adds click event to each header\n     */\n    _addListeners() {\n        if (!this.settings.addListenersOnInit) return;\n\n        // So we can reference the badger-accordion object inside out eventListener\n        const _this = this;\n\n        // Adding click event to accordion\n        this.headers.forEach((header, index) => {\n            header.addEventListener('click', function() {\n                // Getting the target of the click\n                // const clickedEl = event.target;\n\n                _this.handleClick(header, index);\n            });\n        });\n    }\n\n\n    /**\n     *  HANDLE CLICK\n     *\n     *  Handles click and checks if click was on an header element\n     *  @param {object} targetHeader - The header node you want to open\n     */\n    handleClick(targetHeader, headerIndex) {\n        // Removing current `.` from `this.settings.headerClass` class so it can\n        // be checked against the `targetHeader` classList\n        const targetHeaderClass = this.settings.headerClass.substr(1);\n\n        // Checking that the thing that was clicked on was the accordions header\n        if (targetHeader.classList.contains(targetHeaderClass) && this.toggling === false) {\n            this.toggling = true;\n\n            // Updating states\n            this.setState(headerIndex);\n\n            // Render DOM as per the updates `this.states` object\n            this._renderDom();\n        }\n    }\n\n\n    /**\n     *  SET STATES\n     *\n     *  Sets the state for all headers. The 'target header' will have its state toggeled\n     *  @param {object} targetHeaderId - The header node you want to open\n     */\n    setState(targetHeaderId) {\n        const states = this.getState();\n\n        // If `this.settings.openMultiplePanels` is false we need to ensure only one panel\n        // be can open at once. If it is false then all panels state APART from the one that\n        // has just been clicked needs to be set to 'closed'.\n        if (!this.settings.openMultiplePanels) {\n            states.filter((state, index) => {\n                if (index != targetHeaderId) {\n                    state.state = 'closed';\n                }\n            });\n        }\n\n        // Toggles the state value of the target header. This was `array.find` but `find`\n        // isnt supported in IE11\n        states.filter((state, index) => {\n            if (index == targetHeaderId) {\n                const newState = this.toggleState(state.state);\n                return (state.state = newState);\n            }\n        });\n    }\n\n\n    /**\n     *  RENDER DOM\n     *\n     *  Renders the accordion in the DOM using the `this.states` object\n     */\n    _renderDom() {\n        // Filter through all open headers and open them\n        this.states.filter( (state, index) => {\n            if(state.state === 'open') {\n                // Opening the current panel but _NOT_ updating the state\n                this.open(index, false);\n            }\n        });\n\n        // Filter through all closed headers and closes them\n        this.states.filter( (state, index) => {\n            if(state.state === 'closed') {\n                // Closing the current panel but _NOT_ updating the state\n                this.close(index, false);\n            }\n        });\n    }\n\n\n    /**\n     *  OPEN\n     *\n     *  Closes a specific panel\n     *  @param {integer} headerIndex - The header node index you want to open\n     */\n    open(headerIndex, setState = true) {\n        // 1. If being fired directly the state needs to be updated.\n        if(setState) {\n            this.setState(headerIndex);\n        }\n\n        this.togglePanel('open', headerIndex);\n    }\n\n\n    /**\n     *  CLOSE\n     *\n     *  Closes a specific panel\n     *  @param {integer} headerIndex - The header node index you want to close\n     */\n    close(headerIndex, setState = true) {\n        // 1. If being fired directly the state needs to be updated.\n        if(setState) {\n            this.setState(headerIndex);\n        }\n\n        this.togglePanel('closed', headerIndex);\n    }\n\n\n    /**\n     *  OPEN ALL\n     *\n     *  Opens all panels\n     */\n    openAll() {\n        this.headers.forEach((header, headerIndex) => {\n            this.togglePanel('open', headerIndex);\n        });\n    }\n\n\n    /**\n     *  CLOSE ALL\n     *\n     *  Closes all panels\n     */\n    closeAll() {\n        this.headers.forEach((header, headerIndex) => {\n            this.togglePanel('closed', headerIndex);\n        });\n    }\n\n\n    /**\n     *  GET STATE\n     *\n     *  Getting state of headers. By default gets state of all headers\n     *  @param {string} animationAction - The animation you want to invoke\n     *  @param {integer} headerIndex    - The header node index you want to animate\n     */\n    togglePanel(animationAction, headerIndex) {\n        if(animationAction !== undefined && headerIndex !== undefined) {\n            if(animationAction === 'closed') {\n                // 1. Getting ID of panel that we want to close\n                const header        = this.headers[headerIndex];\n                const panelToClose  = this.panels[headerIndex];\n\n                // 2. Closeing panel\n                panelToClose.classList.add(this.settings.hiddenClass);\n\n                // 3. Removing active classes\n                panelToClose.classList.remove(this.settings.activeClass);\n                header.classList.remove(this.settings.activeClass);\n\n                // 4. Set aria attrs\n                header.setAttribute('aria-expanded', false);\n\n                // 5. Resetting toggling so a new event can be fired\n                panelToClose.onCSSTransitionEnd(() => this.toggling = false );\n            } else if(animationAction === 'open') {\n                // 1. Getting ID of panel that we want to open\n                const header      = this.headers[headerIndex];\n                const panelToOpen = this.panels[headerIndex];\n\n                // 2. Opening panel\n                panelToOpen.classList.remove(this.settings.hiddenClass);\n\n                // 3. Adding active classes\n                panelToOpen.classList.add(this.settings.activeClass);\n                header.classList.add(this.settings.activeClass);\n\n                // 4. Set aria attrs\n                header.setAttribute('aria-expanded', true);\n\n                // 5. Resetting toggling so a new event can be fired\n                panelToOpen.onCSSTransitionEnd(() => this.toggling = false );\n            }\n        }\n    }\n\n\n    // @TODO - is this needed anymore?\n    // checkState(headerId) {\n    //     let state = this.states[headerId].state;\n    //\n    //     if(state === 'closed') {\n    //         return state;\n    //     } else if(state === 'open') {\n    //         return state;\n    //     }\n    // }\n\n\n    /**\n     *  GET STATE\n     *\n     *  Getting state of headers. By default gets state of all headers\n     *  @param {array} headerIds - Id/'s of the headers you want to check\n     */\n    getState(headerIds = []) {\n        if(headerIds.length && Array.isArray(headerIds)) {\n            let states = headerIds.map( header => this.states[header] );\n\n            return states;\n        } else {\n            return this.states;\n        }\n    }\n\n\n    /**\n     *  TOGGLE STATE\n     *\n     *  Toggling the state value\n     *  @param {string} currentState - Current state value for a header\n     */\n    toggleState(currentState) {\n        if(currentState !== undefined) {\n            return (currentState === 'closed') ? 'open' : 'closed';\n        }\n    }\n\n\n\n    /**\n     *  HEADERS TO OPEN\n     *\n     *  Setting which headers should be open when accordion is initalised\n     *  @param {array} headersToOpen - Array of ID's for the headers to be open\n     */\n    _openHeadersOnLoad(headersToOpen = []) {\n        if (headersToOpen.length && Array.isArray(headersToOpen)) {\n            let headers = headersToOpen.filter(header => header != undefined);\n\n            headers.forEach(header => {\n                this.setState(header);\n            });\n        }\n    }\n\n\n    /**\n     *  SET UP ATTRIBUTES\n     *\n     *  Initalises accordion attribute methods\n     */\n    _setupAttributes() {\n        // Adding ID & aria-controls\n        this._setupHeaders();\n\n        // Adding ID & aria-labelledby\n        this._setupPanels();\n\n        // Inserting data-attribute onto each `header`\n        this._insertDataAttrs();\n    }\n\n\n\n    /**\n     *  SET PANEL HEIGHT - ** DEPRICATED **\n     *\n     *  Depreicated as this method is becoming public and\n     *  I want to name it something that lets devs know\n     *  it's not just for using inside the `init()` method.\n     */\n    _setPanelHeight() {\n        this.calculateAllPanelsHeight();\n    }\n\n\n\n    /**\n     *  CALCULATE PANEL HEIGHT\n     *\n     *  Setting height for panels using pannels inner element\n     */\n    calculatePanelHeight(panel) {\n        const panelInner = panel.querySelector(this.settings.panelInnerClass);\n\n        let activeHeight = panelInner.offsetHeight;\n\n        return panel.style.maxHeight = `${activeHeight}px`;\n    }\n\n\n\n    /**\n     *  CALCULATE PANEL HEIGHT\n     *\n     *  Setting height for panels using pannels inner element\n     */\n    calculateAllPanelsHeight() {\n        this.panels.forEach(panel => {\n            this.calculatePanelHeight(panel);\n        });\n    }\n\n\n\n    /**\n     * SET UP HEADERS\n     */\n    _setupHeaders() {\n        this.headers.forEach( (header, index) => {\n            header.setAttribute('id', `badger-accordion-header-${this.ids[index].id}`);\n            header.setAttribute('aria-controls', `badger-accordion-panel-${this.ids[index].id}`);\n        });\n    }\n\n\n    /**\n     * SET UP PANELS\n     */\n    _setupPanels() {\n        this.panels.forEach( (panel, index) => {\n            panel.setAttribute('id', `badger-accordion-panel-${this.ids[index].id}`);\n            panel.setAttribute('aria-labelledby', `badger-accordion-header-${this.ids[index].id}`);\n            if(this.settings.roles === true || this.settings.roles.region !== false) {\n                this._setRole('region', panel);\n            }\n        });\n    }\n}\n\n\n// Export\nexport default BadgerAccordion;\n"],"names":["Array","from","toStr","Object","prototype","toString","isCallable","fn","call","toInteger","value","number","Number","isNaN","isFinite","Math","floor","abs","maxSafeInteger","pow","toLength","len","min","max","arrayLike","C","this","items","TypeError","T","mapFn","arguments","length","kValue","A","k","document","window","s","body","documentElement","style","prefixAnimation","prefixTransition","WebkitAnimation","MozAnimation","OAnimation","WebkitTransition","MozTransition","OTransition","defineProperty","callback","runOnce","e","target","removeEventListener","type","addEventListener","getComputedStyle","enumerable","writable","el","options","container","querySelector","defaults","headerClass","panelClass","panelInnerClass","hiddenClass","activeClass","initializedClass","headerDataAttr","openMultiplePanels","openHeadersOnLoad","addListenersOnInit","headerOpenLabel","headerCloseLabel","roles","settings","_extends","children","headerParent","filter","header","classList","contains","_this2","substr","headers","reduce","acc","a","child","concat","panels","panel","toggleEl","undefined","querySelectorAll","states","map","state","ids","id","random","toggling","init","console","log","_setupAttributes","_initalState","calculateAllPanelsHeight","_insertDataAttrs","_addListeners","_finishInitialization","role","setAttribute","headersToOpen","_openHeadersOnLoad","_renderDom","forEach","index","_this3","add","_setRole","_this","handleClick","targetHeader","headerIndex","targetHeaderClass","setState","targetHeaderId","getState","newState","_this4","toggleState","_this5","open","close","togglePanel","_this6","_this7","animationAction","panelToClose","remove","onCSSTransitionEnd","_this8","panelToOpen","headerIds","isArray","_this9","currentState","_this10","_setupHeaders","_setupPanels","activeHeight","offsetHeight","maxHeight","_this11","calculatePanelHeight","_this12","_this13","region"],"mappings":"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"}